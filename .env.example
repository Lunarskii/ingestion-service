# По умолчанию сервис использует локальные заглушки.


# **Настройки API**

# Заголовок API, отображается в UI Swagger.
# [default: "Ingestion Service"]
API_TITLE="Ingestion Service"

# Описание API (Markdown), выводится под заголовком в Swagger.
# [default: ""]
API_DESCRIPTION=""

# Версия API, будет отображаться рядом с заголовком.
# [default: "0.1.0"]
API_VERSION="0.1.0"

# URL, по которому доступна спецификация OpenAPI. Можно отключить (None).
# [default: "/openapi.json"]
OPENAPI_URL="/openapi.json"

# Префикс для всех путей OpenAPI (например, если API за reverse-proxy под /api/v1).
# [default: ""]
OPENAPI_PREFIX = ""

# URL Swagger UI. Можно отключить (None) или изменить (e.g. /api/docs).
# [default: "/docs"]
DOCS_URL="/docs"

# URL ReDoc. Можно отключить (None) или изменить (e.g. /api/redoc).
# [default: "/redoc"]
REDOC_URL="/redoc"

# Если API за proxy с префиксом (например, `X-Forwarded-Prefix`), указываете его здесь.
# [default: ""]
ROOT_PATH=""


# **Настройки базы данных**

# URL для подключения к базе данных
# Схема URL - "dialect+driver://username:password@host:port/dbname"
# [default: "sqlite+aiosqlite:///./local_storage/sqlite.db"]
DATABASE_URL="postgresql+asyncpg://postgres:postgres@localhost:5432/postgres"

# Включает логирование SQL-запросов/операций SQLAlchemy на stdout (или в логгер).
# [default: "False"]
DATABASE_ECHO="False"

# Включает логирование событий пула подключений (чек-аут / возврат соединения)
# [default: "False"]
DATABASE_ECHO_POOL="False"

# Перед выдачей соединения проверяет "alive"-состояние (ping) соединения.
# Если соединение закрыто на стороне сервера, пул выбрасывает его и создаёт новое.
# Это помогает избежать ошибок из-за таймаута/закрытия соединений со стороны БД (особенно у облачных провайдеров).
# [default: "True"]
DATABASE_POOL_PRE_PING="True"

# Когда True, перед выполнением запросов (query/scalar и т.п.) Session автоматически вызывает flush(),
# т.е. отправляет в БД все накопленные изменения (INSERT/UPDATE/DELETE), чтобы результаты запросов
# были последовательны с текущим состоянием сессии.
# [default: "False"]
DATABASE_AUTO_FLUSH="False"

# В старых версиях SQLAlchemy autocommit=True переводило сессию в "режим без транзакции",
# т.е. позволялo выполнять операции без явного begin() / commit().
# Устарел/удалён в подходе SQLAlchemy 2.0; его использование не рекомендуется.
# [default: "False"]
DATABASE_AUTO_COMMIT="False"

# После коммита объекты в сессии помечаются как expired - при следующем доступе к атрибуту
# SQLAlchemy попытается автоматически подгрузить актуальные данные из БД (выполнит SELECT).
# Если False, объекты остаются валидными в памяти и не будут автоматически "проверяться"/обновляться после коммита.
# [default: "False"]
DATABASE_EXPIRE_ON_COMMIT="False"


# **Настройки ограничений документа**

# Максимальный размер загружаемого документа в 'POST /v1/documents/upload'
# [default: "25"]
DR_MAX_UPLOAD_MB="25"

# Разрешенные расширения документа в 'POST /v1/documents/upload'
# [default: '[".pdf", ".docx"]']
DR_ALLOWED_EXTENSIONS='[".pdf", ".docx"]'


# **Настройки эмбеддинг модели**

# Название модели (подготовленная заранее в SentenceTransformer, или Hugging Face Hub) или путь к модели на диске.
# [default: "sentence-transformers/all-MiniLM-L6-v2"]
EMBEDDING_MODEL_NAME="sentence-transformers/all-MiniLM-L6-v2"

# Устройство (например, "cuda", "cpu", "mps", "npu"), которое должно использоваться для вычислений.
# Если None, проверяет, можно ли использовать графический процессор.
# [default: "None"]
EMBEDDING_DEVICE="None"

# Путь к хранилищу моделей. Также может быть задан переменной окружения SENTENCE_TRANSFORMERS_HOME.
# [default: "None"]
EMBEDDING_CACHE_FOLDER="None"

# Аутентификационный токен Hugging Face для загрузки приватных моделей.
# [default: "None"]
EMBEDDING_TOKEN="None"


# **Настройки разделителя текста**

# Максимальная длина одного фрагмента в символах.
# [default: "500"]
TEXT_SPLITTER_CHUNK_SIZE="500"

# Число символов перекрытия между соседними фрагментами.
# [default: "50"]
TEXT_SPLITTER_CHUNK_OVERLAP="50"


# **Настройки заглушек для локальной разработки**

# Путь для хранения необработанных файлов.
# [default: "./local_storage/raw/"]
RAW_STORAGE_PATH="./local_storage/raw/"

# Путь для хранения векторных документов.
# [default: "./local_storage/index/"]
INDEX_PATH="./local_storage/index/"


# **Настройки MinIO**

# Адрес MinIO/S3-совместимого сервера.
# Обычно в виде host:port (например minio.local:9000) или URL без схемы.
# [default: "None"]
MINIO_ENDPOINT="None"

# Имя бакета (bucket), в котором будут храниться сырые файлы.
# [default: "raw-zone"]
MINIO_BUCKET_RAW="raw-zone"

# Имя бакета (bucket), в котором будут храниться обработанные файлы.
# [default: "silver-zone"]
MINIO_BUCKET_SILVER="silver-zone"

# Публичный ключ / идентификатор доступа для аутентификации к MinIO/S3.
# [default: "None"]
MINIO_ACCESS_KEY="None"

# Секретный ключ для подписи запросов к сервису MinIO/S3.
# [default: "None"]
MINIO_SECRET_KEY="None"

# Временный (STS) токен сессии - используется вместе с access_key/secret_key для временных учётных записей.
# [default: "None"]
MINIO_SESSION_TOKEN="None"

# Флаг, указывающий, использовать ли TLS/HTTPS при подключении к адресу MinIO/S3.
# [default: "False"]
MINIO_SECURE="False"

# Имя региона (например, 'us-east-1') - может влиять на создание бакетов и некоторые клиентские настройки.
# [default: "None"]
MINIO_REGION="None"


# **Настройки Qdrant**

# URL сервера Qdrant
# [default: "None"]
QDRANT_URL="None"

# Имя коллекции
# [default: "notebook_chunks"]
QDRANT_COLLECTION="notebook_chunks"

# Хост (альтернативный способ указания адреса)
# [default: "None"]
QDRANT_HOST="None"

# HTTP-порт
# [default: "6333"]
QDRANT_PORT="6333"

# gRPC-порт
# [default: "6334"]
QDRANT_GRPC_PORT="6334"

# API-ключ для доступа (если требуется)
# [default: "None"]
QDRANT_API_KEY="None"

# Использовать HTTPS
# [default: "False"]
QDRANT_USE_HTTPS="False"

# Предпочитать gRPC соединение
# [default: "False"]
QDRANT_PREFER_GRPC="False"

# Таймаут запросов (секунды)
# [default: "30"]
QDRANT_TIMEOUT="30"

# Размерность векторов (число измерений)
# [default: "384"]
QDRANT_VECTOR_SIZE="384"

# Функция расстояния
# Может быть "Dot", "Cosine", "Euclid" и "Manhattan"
# Подробнее - https://qdrant.tech/documentation/concepts/search/#metrics
# [default: "Cosine"]
QDRANT_DISTANCE="Cosine"


# **Настройки логирования**

# Уровень логирования (TRACE, DEBUG, INFO, SUCCESS, WARNING, ERROR, CRITICAL)
# [default: "INFO"]
LOG_LEVEL="INFO"

# Формат лога, например "{time} - {level} - {message}"
# Подробнее: https://loguru.readthedocs.io/en/stable/api/logger.html#record
# [default: "{message}"]
LOG_FORMAT="{message}"

# Сериализация в JSON. Может быть True или False
# [default: "True"]
LOG_SERIALIZE="True"

# Ротация логов, например "1 day"
# Подробнее: https://loguru.readthedocs.io/en/stable/api/logger.html#time
# [default: "1 day"]
LOG_ROTATION="1 day"

# Параметр определяет - какие и сколько старых файлов логов вы хотите хранить, а какие автоматически удалять.
# Если вы задаёте его как строку с единицами измерения, например "7 days", то будут сохраняться только архивы логов
# за последние семь дней, а более старые файлы автоматически удалятся. Можно указать ограничение по количеству файлов,
# например "10 files" - будет храниться только 10 самых свежих лог‑архивов.
# Подробнее: https://loguru.readthedocs.io/en/stable/api/logger.html#file
# [default: "14 days"]
LOG_RETENTION="14 days"

# Параметр указывает, как архивировать старые лог-файлы при ротации. Когда достигается условие ротации
# (по размеру, времени и т.п.), текущий лог-файл переименовывается и, если вы задали compression,
# дополнительно сжимается.
# Подробнее: https://loguru.readthedocs.io/en/stable/api/logger.html#file
# [default: "zip"]
LOG_COMPRESSION="zip"


# **Настройки времени**

# Формат сериализации даты и времени.
# В этот формат будут сериализованы все 'datetime' поля, отдаваемые API.
# Подробнее о формате - https://docs.python.org/3/library/datetime.html#format-codes
# [default: "%Y-%m-%d %H:%M:%S"]
DATETIME_SERIALIZATION_FORMAT="%Y-%m-%d %H:%M:%S"
